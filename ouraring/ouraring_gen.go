// Package ouraring provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package ouraring

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ExtApiV2DataType.
const (
	ExtApiV2DataTypeDailyActivity     ExtApiV2DataType = "daily_activity"
	ExtApiV2DataTypeDailyCyclePhases  ExtApiV2DataType = "daily_cycle_phases"
	ExtApiV2DataTypeDailyReadiness    ExtApiV2DataType = "daily_readiness"
	ExtApiV2DataTypeDailySleep        ExtApiV2DataType = "daily_sleep"
	ExtApiV2DataTypeDailySpo2         ExtApiV2DataType = "daily_spo2"
	ExtApiV2DataTypeDailyStress       ExtApiV2DataType = "daily_stress"
	ExtApiV2DataTypeRestModePeriod    ExtApiV2DataType = "rest_mode_period"
	ExtApiV2DataTypeRingConfiguration ExtApiV2DataType = "ring_configuration"
	ExtApiV2DataTypeSession           ExtApiV2DataType = "session"
	ExtApiV2DataTypeSleep             ExtApiV2DataType = "sleep"
	ExtApiV2DataTypeSleepTime         ExtApiV2DataType = "sleep_time"
	ExtApiV2DataTypeTag               ExtApiV2DataType = "tag"
	ExtApiV2DataTypeTagV2             ExtApiV2DataType = "tagV2"
	ExtApiV2DataTypeWorkout           ExtApiV2DataType = "workout"
)

// Defines values for HeartRateSource.
const (
	HeartRateSourceAwake   HeartRateSource = "awake"
	HeartRateSourceLive    HeartRateSource = "live"
	HeartRateSourceRest    HeartRateSource = "rest"
	HeartRateSourceSession HeartRateSource = "session"
	HeartRateSourceSleep   HeartRateSource = "sleep"
	HeartRateSourceWorkout HeartRateSource = "workout"
)

// Defines values for MomentMood.
const (
	Bad   MomentMood = "bad"
	Good  MomentMood = "good"
	Great MomentMood = "great"
	Same  MomentMood = "same"
	Worse MomentMood = "worse"
)

// Defines values for MomentType.
const (
	MomentTypeBodyStatus MomentType = "body_status"
	MomentTypeBreathing  MomentType = "breathing"
	MomentTypeMeditation MomentType = "meditation"
	MomentTypeNap        MomentType = "nap"
	MomentTypeRelaxation MomentType = "relaxation"
	MomentTypeRest       MomentType = "rest"
)

// Defines values for SleepTimeStatus.
const (
	BadSleepQuality       SleepTimeStatus = "bad_sleep_quality"
	NotEnoughNights       SleepTimeStatus = "not_enough_nights"
	NotEnoughRecentNights SleepTimeStatus = "not_enough_recent_nights"
	OnlyRecommendedFound  SleepTimeStatus = "only_recommended_found"
	OptimalFound          SleepTimeStatus = "optimal_found"
)

// Defines values for SleepType.
const (
	SleepTypeDeleted   SleepType = "deleted"
	SleepTypeLateNap   SleepType = "late_nap"
	SleepTypeLongSleep SleepType = "long_sleep"
	SleepTypeRest      SleepType = "rest"
	SleepTypeSleep     SleepType = "sleep"
)

// Defines values for WorkoutIntensity.
const (
	Easy     WorkoutIntensity = "easy"
	Hard     WorkoutIntensity = "hard"
	Moderate WorkoutIntensity = "moderate"
)

// ActivityContributors Object defining activity score contributors.
type ActivityContributors struct {
	// MeetDailyTargets Contribution of meeting previous 7-day daily activity targets in range [1, 100].
	MeetDailyTargets *int `json:"meet_daily_targets"`

	// MoveEveryHour Contribution of previous 24-hour inactivity alerts in range [1, 100].
	MoveEveryHour *int `json:"move_every_hour"`

	// RecoveryTime Contribution of previous 7-day recovery time in range [1, 100].
	RecoveryTime *int `json:"recovery_time"`

	// StayActive Contribution of previous 24-hour activity in range [1, 100].
	StayActive *int `json:"stay_active"`

	// TrainingFrequency Contribution of previous 7-day exercise frequency in range [1, 100].
	TrainingFrequency *int `json:"training_frequency"`

	// TrainingVolume Contribution of previous 7-day exercise volume in range [1, 100].
	TrainingVolume *int `json:"training_volume"`
}

// ArrayNullableFloatBits64 defines model for ArrayNullableFloatBits64.
type ArrayNullableFloatBits64 = []float32

// CreateWebhookSubscriptionRequest defines model for CreateWebhookSubscriptionRequest.
type CreateWebhookSubscriptionRequest struct {
	CallbackUrl string `json:"callback_url"`

	// DataType An enumeration.
	DataType ExtApiV2DataType `json:"data_type"`

	// EventType An enumeration.
	EventType         WebhookOperation `json:"event_type"`
	VerificationToken string           `json:"verification_token"`
}

// DailyActivityModel defines model for DailyActivityModel.
type DailyActivityModel struct {
	// ActiveCalories Active calories expended (in kilocalories)
	ActiveCalories int `json:"active_calories"`

	// AverageMetMinutes Average metabolic equivalent (MET) in minutes
	AverageMetMinutes float32 `json:"average_met_minutes"`

	// Class5Min 5-minute activity classification for the activity period:
	// * ```0```	non wear
	// * ```1``` rest
	// * ```2``` inactive
	// * ```3``` low activity
	// * ```4``` medium activity
	// * ```5``` high activity
	Class5Min *string `json:"class_5_min,omitempty"`

	// Contributors Object defining activity score contributors.
	Contributors ActivityContributors `json:"contributors"`

	// Day The ```YYYY-MM-DD``` formatted local date indicating when the daily activity occurred
	Day openapi_types.Date `json:"day"`

	// EquivalentWalkingDistance Equivalent walking distance (in meters) of energy expenditure
	EquivalentWalkingDistance int `json:"equivalent_walking_distance"`

	// HighActivityMetMinutes High activity metabolic equivalent (MET) in minutes
	HighActivityMetMinutes int `json:"high_activity_met_minutes"`

	// HighActivityTime High activity metabolic equivalent (MET) in seconds
	HighActivityTime int    `json:"high_activity_time"`
	Id               string `json:"id"`

	// InactivityAlerts Number of inactivity alerts received
	InactivityAlerts int `json:"inactivity_alerts"`

	// LowActivityMetMinutes Low activity metabolic equivalent (MET) in minutes
	LowActivityMetMinutes int `json:"low_activity_met_minutes"`

	// LowActivityTime Low activity metabolic equivalent (MET) in seconds
	LowActivityTime int `json:"low_activity_time"`

	// MediumActivityMetMinutes Medium activity metabolic equivalent (MET) in minutes
	MediumActivityMetMinutes int `json:"medium_activity_met_minutes"`

	// MediumActivityTime Medium activity metabolic equivalent (MET) in seconds
	MediumActivityTime int `json:"medium_activity_time"`

	// Met Object defining a recorded sample.
	Met Sample `json:"met"`

	// MetersToTarget Remaining meters to target (from ```target_meters```
	MetersToTarget int `json:"meters_to_target"`

	// NonWearTime The time (in seconds) in which the ring was not worn
	NonWearTime int `json:"non_wear_time"`

	// RestingTime Resting time (in seconds)
	RestingTime int `json:"resting_time"`

	// Score Activity score in range ```[1, 100]```
	Score *int `json:"score,omitempty"`

	// SedentaryMetMinutes Sedentary metabolic equivalent (MET) in minutes
	SedentaryMetMinutes int `json:"sedentary_met_minutes"`

	// SedentaryTime Sedentary metabolic equivalent (MET) in seconds
	SedentaryTime int `json:"sedentary_time"`

	// Steps Total number of steps taken
	Steps int `json:"steps"`

	// TargetCalories Daily activity target (in kilocalories)
	TargetCalories int `json:"target_calories"`

	// TargetMeters Daily activity target (in meters)
	TargetMeters int `json:"target_meters"`

	// Timestamp ISO 8601 formatted local timestamp indicating the start datetime of when the daily activity occurred
	Timestamp time.Time `json:"timestamp"`

	// TotalCalories Total calories expended (in kilocalories)
	TotalCalories int `json:"total_calories"`
}

// DailyReadinessModel defines model for DailyReadinessModel.
type DailyReadinessModel struct {
	// Contributors Contributors of the daily readiness score.
	Contributors ReadinessContributors `json:"contributors"`

	// Day Day that the daily readiness belongs to.
	Day openapi_types.Date `json:"day"`
	Id  string             `json:"id"`

	// Score Daily readiness score.
	Score *int `json:"score,omitempty"`

	// TemperatureDeviation Temperature deviation in degrees Celsius.
	TemperatureDeviation *float32 `json:"temperature_deviation,omitempty"`

	// TemperatureTrendDeviation Temperature trend deviation in degrees Celsius.
	TemperatureTrendDeviation *float32 `json:"temperature_trend_deviation,omitempty"`

	// Timestamp Timestamp of the daily readiness.
	Timestamp time.Time `json:"timestamp"`
}

// DailySleepModel Object defining daily sleep.
type DailySleepModel struct {
	// Contributors Contributors for the daily sleep score.
	Contributors SleepContributors `json:"contributors"`

	// Day Day that the daily sleep belongs to.
	Day openapi_types.Date `json:"day"`
	Id  string             `json:"id"`

	// Score Daily sleep score.
	Score *int `json:"score,omitempty"`

	// Timestamp Timestamp of the daily sleep.
	Timestamp time.Time `json:"timestamp"`
}

// DailySpO2AggregatedValuesModel defines model for DailySpO2AggregatedValuesModel.
type DailySpO2AggregatedValuesModel struct {
	// Average Average oxygen saturation (SpO2) throughout the night.
	Average float32 `json:"average"`
}

// DailySpO2Model defines model for DailySpO2Model.
type DailySpO2Model struct {
	Day openapi_types.Date `json:"day"`
	Id  string             `json:"id"`

	// Spo2Percentage The SpO2 percentage value aggregated over a single day.
	Spo2Percentage *DailySpO2AggregatedValuesModel `json:"spo2_percentage,omitempty"`
}

// ExtApiV2DataType An enumeration.
type ExtApiV2DataType string

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// HeartRateModel defines model for HeartRateModel.
type HeartRateModel struct {
	Bpm int `json:"bpm"`

	// Source An enumeration.
	Source    HeartRateSource `json:"source"`
	Timestamp time.Time       `json:"timestamp"`
}

// HeartRateResponse defines model for HeartRateResponse.
type HeartRateResponse struct {
	Data      []HeartRateModel `json:"data"`
	NextToken *string          `json:"next_token,omitempty"`
}

// HeartRateSource An enumeration.
type HeartRateSource string

// LocalizedDateTime ISO 8601 date-time that requires timezone and milliseconds
type LocalizedDateTime = time.Time

// MomentMood Possible Moment moods.
type MomentMood string

// MomentType Possible Moment types.
type MomentType string

// MultiDocumentResponseDailyActivityModel defines model for MultiDocumentResponse_DailyActivityModel_.
type MultiDocumentResponseDailyActivityModel struct {
	Data      []DailyActivityModel `json:"data"`
	NextToken *string              `json:"next_token,omitempty"`
}

// MultiDocumentResponseDailyReadinessModel defines model for MultiDocumentResponse_DailyReadinessModel_.
type MultiDocumentResponseDailyReadinessModel struct {
	Data      []DailyReadinessModel `json:"data"`
	NextToken *string               `json:"next_token,omitempty"`
}

// MultiDocumentResponseDailySleepModel defines model for MultiDocumentResponse_DailySleepModel_.
type MultiDocumentResponseDailySleepModel struct {
	Data      []DailySleepModel `json:"data"`
	NextToken *string           `json:"next_token,omitempty"`
}

// MultiDocumentResponseDailySpO2Model defines model for MultiDocumentResponse_DailySpO2Model_.
type MultiDocumentResponseDailySpO2Model struct {
	Data      []DailySpO2Model `json:"data"`
	NextToken *string          `json:"next_token,omitempty"`
}

// MultiDocumentResponseRestModePeriodModel defines model for MultiDocumentResponse_RestModePeriodModel_.
type MultiDocumentResponseRestModePeriodModel struct {
	Data      []RestModePeriodModel `json:"data"`
	NextToken *string               `json:"next_token,omitempty"`
}

// MultiDocumentResponseRingConfigurationModel defines model for MultiDocumentResponse_RingConfigurationModel_.
type MultiDocumentResponseRingConfigurationModel struct {
	Data      []RingConfigurationModel `json:"data"`
	NextToken *string                  `json:"next_token,omitempty"`
}

// MultiDocumentResponseSessionModel defines model for MultiDocumentResponse_SessionModel_.
type MultiDocumentResponseSessionModel struct {
	Data      []SessionModel `json:"data"`
	NextToken *string        `json:"next_token,omitempty"`
}

// MultiDocumentResponseSleepModel defines model for MultiDocumentResponse_SleepModel_.
type MultiDocumentResponseSleepModel struct {
	Data      []SleepModel `json:"data"`
	NextToken *string      `json:"next_token,omitempty"`
}

// MultiDocumentResponseSleepTimeModel defines model for MultiDocumentResponse_SleepTimeModel_.
type MultiDocumentResponseSleepTimeModel struct {
	Data      []SleepTimeModel `json:"data"`
	NextToken *string          `json:"next_token,omitempty"`
}

// MultiDocumentResponseTagModel defines model for MultiDocumentResponse_TagModel_.
type MultiDocumentResponseTagModel struct {
	Data      []TagModel `json:"data"`
	NextToken *string    `json:"next_token,omitempty"`
}

// MultiDocumentResponseWorkoutModel defines model for MultiDocumentResponse_WorkoutModel_.
type MultiDocumentResponseWorkoutModel struct {
	Data      []WorkoutModel `json:"data"`
	NextToken *string        `json:"next_token,omitempty"`
}

// PersonalInfoResponse defines model for PersonalInfoResponse.
type PersonalInfoResponse struct {
	Age           *int     `json:"age,omitempty"`
	BiologicalSex *string  `json:"biological_sex,omitempty"`
	Email         *string  `json:"email,omitempty"`
	Height        *float32 `json:"height,omitempty"`
	Id            string   `json:"id"`
	Weight        *float32 `json:"weight,omitempty"`
}

// ReadinessContributors Object defining readiness score contributors.
type ReadinessContributors struct {
	ActivityBalance     *int `json:"activity_balance"`
	BodyTemperature     *int `json:"body_temperature"`
	HrvBalance          *int `json:"hrv_balance"`
	PreviousDayActivity *int `json:"previous_day_activity"`
	PreviousNight       *int `json:"previous_night"`
	RecoveryIndex       *int `json:"recovery_index"`
	RestingHeartRate    *int `json:"resting_heart_rate"`
	SleepBalance        *int `json:"sleep_balance"`
}

// ReadinessSummary defines model for ReadinessSummary.
type ReadinessSummary struct {
	// Contributors Object defining readiness score contributors.
	Contributors              ReadinessContributors `json:"contributors"`
	Score                     *int                  `json:"score,omitempty"`
	TemperatureDeviation      *float32              `json:"temperature_deviation,omitempty"`
	TemperatureTrendDeviation *float32              `json:"temperature_trend_deviation,omitempty"`
}

// RestModeEpisode Object defining a Rest Mode episode.
type RestModeEpisode struct {
	// Tags Tags selected for the episode.
	Tags []string `json:"tags"`

	// Timestamp Timestamp indicating when the episode occurred.
	Timestamp LocalizedDateTime `json:"timestamp"`
}

// RestModePeriodModel Object contains information about rest mode episode.
type RestModePeriodModel struct {
	// EndDay End date of rest mode.
	EndDay *openapi_types.Date `json:"end_day"`

	// EndTime Timestamp when rest mode ended.
	EndTime *time.Time `json:"end_time"`

	// Episodes Collection of episodes during rest mode, consisting of tags.
	Episodes []RestModeEpisode `json:"episodes"`
	Id       string            `json:"id"`

	// StartDay Start date of rest mode.
	StartDay openapi_types.Date `json:"start_day"`

	// StartTime Timestamp when rest mode started.
	StartTime time.Time `json:"start_time"`
}

// RingColor An enumeration.
type RingColor = interface{}

// RingConfigurationModel defines model for RingConfigurationModel.
type RingConfigurationModel struct {
	// Color Color of the ring.
	Color *RingColor `json:"color"`

	// Design Design of the ring.
	Design *RingDesign `json:"design"`

	// FirmwareVersion Firmware version of the ring.
	FirmwareVersion *string `json:"firmware_version"`

	// HardwareType Hardware type of the ring.
	HardwareType *RingHardwareType `json:"hardware_type"`
	Id           string            `json:"id"`

	// SetUpAt UTC timestamp indicating when the ring was set up.
	SetUpAt *time.Time `json:"set_up_at"`

	// Size US size of the ring.
	Size *int `json:"size"`
}

// RingDesign An enumeration.
type RingDesign = interface{}

// RingHardwareType An enumeration.
type RingHardwareType = interface{}

// Sample Object defining a recorded sample.
type Sample struct {
	// Interval Interval in seconds between the sampled items.
	Interval float32 `json:"interval"`

	// Items Recorded sample items.
	Items ArrayNullableFloatBits64 `json:"items"`

	// Timestamp Timestamp when the sample recording started.
	Timestamp LocalizedDateTime `json:"timestamp"`
}

// SessionModel defines model for SessionModel.
type SessionModel struct {
	// Day The date when the session occurred.
	Day openapi_types.Date `json:"day"`

	// EndDatetime Timestamp indicating when the Moment ended.
	EndDatetime time.Time `json:"end_datetime"`

	// HeartRate Object defining a recorded sample.
	HeartRate *Sample `json:"heart_rate,omitempty"`

	// HeartRateVariability Object defining a recorded sample.
	HeartRateVariability *Sample `json:"heart_rate_variability,omitempty"`
	Id                   string  `json:"id"`

	// Mood Possible Moment moods.
	Mood *MomentMood `json:"mood,omitempty"`

	// MotionCount Object defining a recorded sample.
	MotionCount *Sample `json:"motion_count,omitempty"`

	// StartDatetime Timestamp indicating when the Moment ended.
	StartDatetime time.Time `json:"start_datetime"`

	// Type Possible Moment types.
	Type MomentType `json:"type"`
}

// SleepAlgorithmVersion An enumeration.
type SleepAlgorithmVersion = interface{}

// SleepContributors Object defining sleep score contributors.
type SleepContributors struct {
	// DeepSleep Contribution of deep sleep in range [1, 100].
	DeepSleep *int `json:"deep_sleep"`

	// Efficiency Contribution of sleep efficiency in range [1, 100].
	Efficiency *int `json:"efficiency"`

	// Latency Contribution of sleep latency in range [1, 100].
	Latency *int `json:"latency"`

	// RemSleep Contribution of REM sleep in range [1, 100].
	RemSleep *int `json:"rem_sleep"`

	// Restfulness Contribution of sleep restfulness in range [1, 100].
	Restfulness *int `json:"restfulness"`

	// Timing Contribution of sleep timing in range [1, 100].
	Timing *int `json:"timing"`

	// TotalSleep Contribution of total sleep in range [1, 100].
	TotalSleep *int `json:"total_sleep"`
}

// SleepModel defines model for SleepModel.
type SleepModel struct {
	// AverageBreath Average breathing rate during sleep as breaths/second.
	AverageBreath *float32 `json:"average_breath,omitempty"`

	// AverageHeartRate Average heart rate during sleep as beats/minute.
	AverageHeartRate *float32 `json:"average_heart_rate,omitempty"`

	// AverageHrv Average heart rate variability during sleep.
	AverageHrv *int `json:"average_hrv,omitempty"`

	// AwakeTime Duration spent awake in seconds.
	AwakeTime *int `json:"awake_time,omitempty"`

	// BedtimeEnd Bedtime end of the sleep.
	BedtimeEnd time.Time `json:"bedtime_end"`

	// BedtimeStart Bedtime start of the sleep.
	BedtimeStart time.Time `json:"bedtime_start"`

	// Day Day that the sleep belongs to.
	Day openapi_types.Date `json:"day"`

	// DeepSleepDuration Duration spent in deep sleep in seconds.
	DeepSleepDuration *int `json:"deep_sleep_duration,omitempty"`

	// Efficiency Sleep efficiency rating in range [1, 100].
	Efficiency *int `json:"efficiency,omitempty"`

	// HeartRate Object containing heart rate samples.
	HeartRate *Sample `json:"heart_rate,omitempty"`

	// Hrv Object defining a recorded sample.
	Hrv *Sample `json:"hrv,omitempty"`
	Id  string  `json:"id"`

	// Latency Sleep latency in seconds. This is the time it took for the user to fall asleep after going to bed.
	Latency *int `json:"latency,omitempty"`

	// LightSleepDuration Duration spent in light sleep in seconds.
	LightSleepDuration *int `json:"light_sleep_duration,omitempty"`

	// LowBatteryAlert Flag indicating if a low battery alert occurred.
	LowBatteryAlert bool `json:"low_battery_alert"`

	// LowestHeartRate Lowest heart rate during sleep.
	LowestHeartRate *int `json:"lowest_heart_rate,omitempty"`

	// Movement30Sec
	//         30-second movement classification for the period where every character corresponds to:
	//         '1' = no motion,
	//         '2' = restless,
	//         '3' = tossing and turning
	//         '4' = active
	//
	Movement30Sec *string `json:"movement_30_sec,omitempty"`

	// Period ECore sleep period identifier.
	Period int `json:"period"`

	// Readiness Object containing the readiness details for this sleep. As opposed to the daily readiness object which represents the readiness for the entire day.
	Readiness *ReadinessSummary `json:"readiness,omitempty"`

	// ReadinessScoreDelta Effect on readiness score caused by this sleep period.
	ReadinessScoreDelta *int `json:"readiness_score_delta,omitempty"`

	// RemSleepDuration Duration spent in REM sleep in seconds.
	RemSleepDuration *int `json:"rem_sleep_duration,omitempty"`

	// RestlessPeriods Number of restless periods during sleep.
	RestlessPeriods *int `json:"restless_periods,omitempty"`

	// SleepAlgorithmVersion Version of the sleep algorithm used to calculate the sleep data.
	SleepAlgorithmVersion *SleepAlgorithmVersion `json:"sleep_algorithm_version,omitempty"`

	// SleepPhase5Min
	//         5-minute sleep phase classification for the period where every character corresponds to:
	//         '1' = deep sleep,
	//         '2' = light sleep,
	//         '3' = REM sleep
	//         '4' = awake.
	//
	SleepPhase5Min *string `json:"sleep_phase_5_min,omitempty"`

	// SleepScoreDelta Effect on sleep score caused by this sleep period.
	SleepScoreDelta *int `json:"sleep_score_delta,omitempty"`

	// TimeInBed Duration spent in bed in seconds.
	TimeInBed int `json:"time_in_bed"`

	// TotalSleepDuration Total sleep duration in seconds.
	TotalSleepDuration *int `json:"total_sleep_duration,omitempty"`

	// Type Possible sleep period types.
	Type SleepType `json:"type"`
}

// SleepTimeModel Object contains suggested bedtime for the user.
type SleepTimeModel struct {
	// Day Corresponding day for the sleep time.
	Day openapi_types.Date `json:"day"`
	Id  string             `json:"id"`

	// OptimalBedtime Optimal bedtime.
	OptimalBedtime *SleepTimeWindow `json:"optimal_bedtime"`

	// Recommendation Recommended action for bedtime.
	Recommendation *SleepTimeRecommendation `json:"recommendation"`

	// Status Sleep time status; used to inform sleep time recommendation.
	Status *SleepTimeStatus `json:"status"`
}

// SleepTimeRecommendation Possible SleepTime recommendation.
type SleepTimeRecommendation = interface{}

// SleepTimeStatus Possible SleepTime status.
type SleepTimeStatus string

// SleepTimeWindow Object defining sleep time window
type SleepTimeWindow struct {
	// DayTz Timezone offset in second from GMT of the day
	DayTz int `json:"day_tz"`

	// EndOffset End offset from midnight in second
	EndOffset int `json:"end_offset"`

	// StartOffset Start offset from midnight in second
	StartOffset int `json:"start_offset"`
}

// SleepType Possible sleep period types.
type SleepType string

// TagModel A TagModel maps to an ASSANote. An ASSANote in ExtAPIV2 is called a Tag
// A TagModel will be populated by data from an ASSANote
// The fields in the TagModel map to fields in an ASSANote
type TagModel struct {
	// Day Day that the note belongs to.
	Day openapi_types.Date `json:"day"`
	Id  string             `json:"id"`

	// Tags Selected tags for the tag.
	Tags []string `json:"tags"`

	// Text Textual contents of the note.
	Text *string `json:"text,omitempty"`

	// Timestamp Timestamp of the note.
	Timestamp time.Time `json:"timestamp"`
}

// UpdateWebhookSubscriptionRequest defines model for UpdateWebhookSubscriptionRequest.
type UpdateWebhookSubscriptionRequest struct {
	CallbackUrl *string `json:"callback_url,omitempty"`

	// DataType An enumeration.
	DataType *ExtApiV2DataType `json:"data_type,omitempty"`

	// EventType An enumeration.
	EventType         *WebhookOperation `json:"event_type,omitempty"`
	VerificationToken string            `json:"verification_token"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []string `json:"loc"`
	Msg  string   `json:"msg"`
	Type string   `json:"type"`
}

// WebhookOperation An enumeration.
type WebhookOperation = interface{}

// WebhookSubscriptionModel defines model for WebhookSubscriptionModel.
type WebhookSubscriptionModel struct {
	CallbackUrl string `json:"callback_url"`

	// DataType An enumeration.
	DataType ExtApiV2DataType `json:"data_type"`

	// EventType An enumeration.
	EventType      WebhookOperation `json:"event_type"`
	ExpirationTime time.Time        `json:"expiration_time"`
	Id             string           `json:"id"`
}

// WorkoutIntensity Possible workout intensities.
type WorkoutIntensity string

// WorkoutModel defines model for WorkoutModel.
type WorkoutModel struct {
	// Activity Type of the workout activity.
	Activity string `json:"activity"`

	// Calories Energy burned in kilocalories during the workout.
	Calories *float32 `json:"calories,omitempty"`

	// Day Day when the workout occurred.
	Day openapi_types.Date `json:"day"`

	// Distance Distance traveled in meters during the workout.
	Distance *float32 `json:"distance,omitempty"`

	// EndDatetime Timestamp indicating when the workout ended.
	EndDatetime time.Time `json:"end_datetime"`
	Id          string    `json:"id"`

	// Intensity Possible workout intensities.
	Intensity WorkoutIntensity `json:"intensity"`

	// Label User-defined label for the workout.
	Label *string `json:"label,omitempty"`

	// Source Possible workout sources.
	Source WorkoutSource `json:"source"`

	// StartDatetime Timestamp indicating when the workout started.
	StartDatetime time.Time `json:"start_datetime"`
}

// WorkoutSource An enumeration.
type WorkoutSource = interface{}

// MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams defines parameters for MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet.
type MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams defines parameters for MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet.
type MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams defines parameters for MultipleDailySleepDocumentsV2UsercollectionDailySleepGet.
type MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams defines parameters for MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get.
type MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams defines parameters for MultipleHeartRateDocumentsV2UsercollectionHeartrateGet.
type MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams struct {
	StartDatetime *time.Time `form:"start_datetime,omitempty" json:"start_datetime,omitempty"`
	EndDatetime   *time.Time `form:"end_datetime,omitempty" json:"end_datetime,omitempty"`
	NextToken     *string    `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams defines parameters for MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet.
type MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams defines parameters for MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet.
type MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleSessionDocumentsV2UsercollectionSessionGetParams defines parameters for MultipleSessionDocumentsV2UsercollectionSessionGet.
type MultipleSessionDocumentsV2UsercollectionSessionGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleSleepDocumentsV2UsercollectionSleepGetParams defines parameters for MultipleSleepDocumentsV2UsercollectionSleepGet.
type MultipleSleepDocumentsV2UsercollectionSleepGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams defines parameters for MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet.
type MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleTagDocumentsV2UsercollectionTagGetParams defines parameters for MultipleTagDocumentsV2UsercollectionTagGet.
type MultipleTagDocumentsV2UsercollectionTagGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams defines parameters for MultipleWorkoutDocumentsV2UsercollectionWorkoutGet.
type MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams struct {
	StartDate *openapi_types.Date `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate   *openapi_types.Date `form:"end_date,omitempty" json:"end_date,omitempty"`
	NextToken *string             `form:"next_token,omitempty" json:"next_token,omitempty"`
}

// CreateWebhookSubscriptionV2WebhookSubscriptionPostJSONRequestBody defines body for CreateWebhookSubscriptionV2WebhookSubscriptionPost for application/json ContentType.
type CreateWebhookSubscriptionV2WebhookSubscriptionPostJSONRequestBody = CreateWebhookSubscriptionRequest

// UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutJSONRequestBody defines body for UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut for application/json ContentType.
type UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutJSONRequestBody = UpdateWebhookSubscriptionRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet request
	MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet(ctx context.Context, params *MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet request
	SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet request
	MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet(ctx context.Context, params *MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet request
	SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleDailySleepDocumentsV2UsercollectionDailySleepGet request
	MultipleDailySleepDocumentsV2UsercollectionDailySleepGet(ctx context.Context, params *MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet request
	SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get request
	MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get(ctx context.Context, params *MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet request
	SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleHeartRateDocumentsV2UsercollectionHeartrateGet request
	MultipleHeartRateDocumentsV2UsercollectionHeartrateGet(ctx context.Context, params *MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet request
	SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet request
	MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet(ctx context.Context, params *MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet request
	SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet request
	MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet(ctx context.Context, params *MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet request
	SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleSessionDocumentsV2UsercollectionSessionGet request
	MultipleSessionDocumentsV2UsercollectionSessionGet(ctx context.Context, params *MultipleSessionDocumentsV2UsercollectionSessionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleSessionDocumentV2UsercollectionSessionDocumentIdGet request
	SingleSessionDocumentV2UsercollectionSessionDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleSleepDocumentsV2UsercollectionSleepGet request
	MultipleSleepDocumentsV2UsercollectionSleepGet(ctx context.Context, params *MultipleSleepDocumentsV2UsercollectionSleepGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleSleepDocumentV2UsercollectionSleepDocumentIdGet request
	SingleSleepDocumentV2UsercollectionSleepDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet request
	MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet(ctx context.Context, params *MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet request
	SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleTagDocumentsV2UsercollectionTagGet request
	MultipleTagDocumentsV2UsercollectionTagGet(ctx context.Context, params *MultipleTagDocumentsV2UsercollectionTagGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleTagDocumentV2UsercollectionTagDocumentIdGet request
	SingleTagDocumentV2UsercollectionTagDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MultipleWorkoutDocumentsV2UsercollectionWorkoutGet request
	MultipleWorkoutDocumentsV2UsercollectionWorkoutGet(ctx context.Context, params *MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet request
	SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhookSubscriptionsV2WebhookSubscriptionGet request
	ListWebhookSubscriptionsV2WebhookSubscriptionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBody request with any body
	CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhookSubscriptionV2WebhookSubscriptionPost(ctx context.Context, body CreateWebhookSubscriptionV2WebhookSubscriptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut request
	RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete request
	DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookSubscriptionV2WebhookSubscriptionIdGet request
	GetWebhookSubscriptionV2WebhookSubscriptionIdGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBody request with any body
	UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut(ctx context.Context, id string, body UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet(ctx context.Context, params *MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet(ctx context.Context, params *MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleDailySleepDocumentsV2UsercollectionDailySleepGet(ctx context.Context, params *MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleDailySleepDocumentsV2UsercollectionDailySleepGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get(ctx context.Context, params *MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleHeartRateDocumentsV2UsercollectionHeartrateGet(ctx context.Context, params *MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleHeartRateDocumentsV2UsercollectionHeartrateGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet(ctx context.Context, params *MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet(ctx context.Context, params *MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleSessionDocumentsV2UsercollectionSessionGet(ctx context.Context, params *MultipleSessionDocumentsV2UsercollectionSessionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleSessionDocumentsV2UsercollectionSessionGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleSessionDocumentV2UsercollectionSessionDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleSessionDocumentV2UsercollectionSessionDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleSleepDocumentsV2UsercollectionSleepGet(ctx context.Context, params *MultipleSleepDocumentsV2UsercollectionSleepGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleSleepDocumentsV2UsercollectionSleepGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleSleepDocumentV2UsercollectionSleepDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleSleepDocumentV2UsercollectionSleepDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet(ctx context.Context, params *MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleTagDocumentsV2UsercollectionTagGet(ctx context.Context, params *MultipleTagDocumentsV2UsercollectionTagGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleTagDocumentsV2UsercollectionTagGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleTagDocumentV2UsercollectionTagDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleTagDocumentV2UsercollectionTagDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MultipleWorkoutDocumentsV2UsercollectionWorkoutGet(ctx context.Context, params *MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMultipleWorkoutDocumentsV2UsercollectionWorkoutGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetRequest(c.Server, documentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhookSubscriptionsV2WebhookSubscriptionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhookSubscriptionsV2WebhookSubscriptionGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSubscriptionV2WebhookSubscriptionPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookSubscriptionV2WebhookSubscriptionPost(ctx context.Context, body CreateWebhookSubscriptionV2WebhookSubscriptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookSubscriptionV2WebhookSubscriptionPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookSubscriptionV2WebhookSubscriptionIdGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookSubscriptionV2WebhookSubscriptionIdGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut(ctx context.Context, id string, body UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewMultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetRequest generates requests for MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet
func NewMultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetRequest(server string, params *MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_activity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetRequest generates requests for SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet
func NewSingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_activity/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetRequest generates requests for MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet
func NewMultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetRequest(server string, params *MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_readiness")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetRequest generates requests for SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet
func NewSingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_readiness/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleDailySleepDocumentsV2UsercollectionDailySleepGetRequest generates requests for MultipleDailySleepDocumentsV2UsercollectionDailySleepGet
func NewMultipleDailySleepDocumentsV2UsercollectionDailySleepGetRequest(server string, params *MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_sleep")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetRequest generates requests for SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet
func NewSingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_sleep/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetRequest generates requests for MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get
func NewMultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetRequest(server string, params *MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_spo2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetRequest generates requests for SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet
func NewSingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/daily_spo2/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleHeartRateDocumentsV2UsercollectionHeartrateGetRequest generates requests for MultipleHeartRateDocumentsV2UsercollectionHeartrateGet
func NewMultipleHeartRateDocumentsV2UsercollectionHeartrateGetRequest(server string, params *MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/heartrate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDatetime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_datetime", runtime.ParamLocationQuery, *params.StartDatetime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDatetime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_datetime", runtime.ParamLocationQuery, *params.EndDatetime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetRequest generates requests for SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet
func NewSinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/personal_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetRequest generates requests for MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet
func NewMultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetRequest(server string, params *MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/rest_mode_period")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetRequest generates requests for SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet
func NewSingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/rest_mode_period/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetRequest generates requests for MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet
func NewMultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetRequest(server string, params *MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/ring_configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetRequest generates requests for SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet
func NewSingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/ring_configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleSessionDocumentsV2UsercollectionSessionGetRequest generates requests for MultipleSessionDocumentsV2UsercollectionSessionGet
func NewMultipleSessionDocumentsV2UsercollectionSessionGetRequest(server string, params *MultipleSessionDocumentsV2UsercollectionSessionGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleSessionDocumentV2UsercollectionSessionDocumentIdGetRequest generates requests for SingleSessionDocumentV2UsercollectionSessionDocumentIdGet
func NewSingleSessionDocumentV2UsercollectionSessionDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/session/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleSleepDocumentsV2UsercollectionSleepGetRequest generates requests for MultipleSleepDocumentsV2UsercollectionSleepGet
func NewMultipleSleepDocumentsV2UsercollectionSleepGetRequest(server string, params *MultipleSleepDocumentsV2UsercollectionSleepGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/sleep")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleSleepDocumentV2UsercollectionSleepDocumentIdGetRequest generates requests for SingleSleepDocumentV2UsercollectionSleepDocumentIdGet
func NewSingleSleepDocumentV2UsercollectionSleepDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/sleep/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetRequest generates requests for MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet
func NewMultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetRequest(server string, params *MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/sleep_time")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetRequest generates requests for SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet
func NewSingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/sleep_time/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleTagDocumentsV2UsercollectionTagGetRequest generates requests for MultipleTagDocumentsV2UsercollectionTagGet
func NewMultipleTagDocumentsV2UsercollectionTagGetRequest(server string, params *MultipleTagDocumentsV2UsercollectionTagGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleTagDocumentV2UsercollectionTagDocumentIdGetRequest generates requests for SingleTagDocumentV2UsercollectionTagDocumentIdGet
func NewSingleTagDocumentV2UsercollectionTagDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/tag/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMultipleWorkoutDocumentsV2UsercollectionWorkoutGetRequest generates requests for MultipleWorkoutDocumentsV2UsercollectionWorkoutGet
func NewMultipleWorkoutDocumentsV2UsercollectionWorkoutGetRequest(server string, params *MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/workout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_token", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetRequest generates requests for SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet
func NewSingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetRequest(server string, documentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "document_id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/usercollection/workout/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWebhookSubscriptionsV2WebhookSubscriptionGetRequest generates requests for ListWebhookSubscriptionsV2WebhookSubscriptionGet
func NewListWebhookSubscriptionsV2WebhookSubscriptionGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/webhook/subscription")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWebhookSubscriptionV2WebhookSubscriptionPostRequest calls the generic CreateWebhookSubscriptionV2WebhookSubscriptionPost builder with application/json body
func NewCreateWebhookSubscriptionV2WebhookSubscriptionPostRequest(server string, body CreateWebhookSubscriptionV2WebhookSubscriptionPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookSubscriptionV2WebhookSubscriptionPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebhookSubscriptionV2WebhookSubscriptionPostRequestWithBody generates requests for CreateWebhookSubscriptionV2WebhookSubscriptionPost with any type of body
func NewCreateWebhookSubscriptionV2WebhookSubscriptionPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/webhook/subscription")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutRequest generates requests for RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut
func NewRenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/webhook/subscription/renew/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteRequest generates requests for DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete
func NewDeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/webhook/subscription/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookSubscriptionV2WebhookSubscriptionIdGetRequest generates requests for GetWebhookSubscriptionV2WebhookSubscriptionIdGet
func NewGetWebhookSubscriptionV2WebhookSubscriptionIdGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/webhook/subscription/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutRequest calls the generic UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut builder with application/json body
func NewUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutRequest(server string, id string, body UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutRequestWithBody generates requests for UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut with any type of body
func NewUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/webhook/subscription/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetWithResponse request
	MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetWithResponse(ctx context.Context, params *MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams, reqEditors ...RequestEditorFn) (*MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse, error)

	// SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetWithResponse request
	SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse, error)

	// MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetWithResponse request
	MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetWithResponse(ctx context.Context, params *MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams, reqEditors ...RequestEditorFn) (*MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse, error)

	// SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetWithResponse request
	SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse, error)

	// MultipleDailySleepDocumentsV2UsercollectionDailySleepGetWithResponse request
	MultipleDailySleepDocumentsV2UsercollectionDailySleepGetWithResponse(ctx context.Context, params *MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams, reqEditors ...RequestEditorFn) (*MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse, error)

	// SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetWithResponse request
	SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse, error)

	// MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetWithResponse request
	MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetWithResponse(ctx context.Context, params *MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams, reqEditors ...RequestEditorFn) (*MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse, error)

	// SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetWithResponse request
	SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse, error)

	// MultipleHeartRateDocumentsV2UsercollectionHeartrateGetWithResponse request
	MultipleHeartRateDocumentsV2UsercollectionHeartrateGetWithResponse(ctx context.Context, params *MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams, reqEditors ...RequestEditorFn) (*MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse, error)

	// SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetWithResponse request
	SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse, error)

	// MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetWithResponse request
	MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetWithResponse(ctx context.Context, params *MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams, reqEditors ...RequestEditorFn) (*MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse, error)

	// SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetWithResponse request
	SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse, error)

	// MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetWithResponse request
	MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetWithResponse(ctx context.Context, params *MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams, reqEditors ...RequestEditorFn) (*MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse, error)

	// SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetWithResponse request
	SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse, error)

	// MultipleSessionDocumentsV2UsercollectionSessionGetWithResponse request
	MultipleSessionDocumentsV2UsercollectionSessionGetWithResponse(ctx context.Context, params *MultipleSessionDocumentsV2UsercollectionSessionGetParams, reqEditors ...RequestEditorFn) (*MultipleSessionDocumentsV2UsercollectionSessionGetResponse, error)

	// SingleSessionDocumentV2UsercollectionSessionDocumentIdGetWithResponse request
	SingleSessionDocumentV2UsercollectionSessionDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse, error)

	// MultipleSleepDocumentsV2UsercollectionSleepGetWithResponse request
	MultipleSleepDocumentsV2UsercollectionSleepGetWithResponse(ctx context.Context, params *MultipleSleepDocumentsV2UsercollectionSleepGetParams, reqEditors ...RequestEditorFn) (*MultipleSleepDocumentsV2UsercollectionSleepGetResponse, error)

	// SingleSleepDocumentV2UsercollectionSleepDocumentIdGetWithResponse request
	SingleSleepDocumentV2UsercollectionSleepDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse, error)

	// MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetWithResponse request
	MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetWithResponse(ctx context.Context, params *MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams, reqEditors ...RequestEditorFn) (*MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse, error)

	// SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetWithResponse request
	SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse, error)

	// MultipleTagDocumentsV2UsercollectionTagGetWithResponse request
	MultipleTagDocumentsV2UsercollectionTagGetWithResponse(ctx context.Context, params *MultipleTagDocumentsV2UsercollectionTagGetParams, reqEditors ...RequestEditorFn) (*MultipleTagDocumentsV2UsercollectionTagGetResponse, error)

	// SingleTagDocumentV2UsercollectionTagDocumentIdGetWithResponse request
	SingleTagDocumentV2UsercollectionTagDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse, error)

	// MultipleWorkoutDocumentsV2UsercollectionWorkoutGetWithResponse request
	MultipleWorkoutDocumentsV2UsercollectionWorkoutGetWithResponse(ctx context.Context, params *MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams, reqEditors ...RequestEditorFn) (*MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse, error)

	// SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetWithResponse request
	SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse, error)

	// ListWebhookSubscriptionsV2WebhookSubscriptionGetWithResponse request
	ListWebhookSubscriptionsV2WebhookSubscriptionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse, error)

	// CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBodyWithResponse request with any body
	CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse, error)

	CreateWebhookSubscriptionV2WebhookSubscriptionPostWithResponse(ctx context.Context, body CreateWebhookSubscriptionV2WebhookSubscriptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse, error)

	// RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutWithResponse request
	RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse, error)

	// DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteWithResponse request
	DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse, error)

	// GetWebhookSubscriptionV2WebhookSubscriptionIdGetWithResponse request
	GetWebhookSubscriptionV2WebhookSubscriptionIdGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse, error)

	// UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBodyWithResponse request with any body
	UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse, error)

	UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithResponse(ctx context.Context, id string, body UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse, error)
}

type MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseDailyActivityModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyActivityModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseDailyReadinessModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyReadinessModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseDailySleepModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailySleepModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseDailySpO2Model
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailySpO2Model
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HeartRateResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonalInfoResponse
}

// Status returns HTTPResponse.Status
func (r SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseRestModePeriodModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestModePeriodModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseRingConfigurationModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RingConfigurationModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleSessionDocumentsV2UsercollectionSessionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseSessionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleSessionDocumentsV2UsercollectionSessionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleSessionDocumentsV2UsercollectionSessionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleSleepDocumentsV2UsercollectionSleepGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseSleepModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleSleepDocumentsV2UsercollectionSleepGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleSleepDocumentsV2UsercollectionSleepGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SleepModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseSleepTimeModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SleepTimeModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleTagDocumentsV2UsercollectionTagGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseTagModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleTagDocumentsV2UsercollectionTagGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleTagDocumentsV2UsercollectionTagGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MultiDocumentResponseWorkoutModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkoutModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WebhookSubscriptionModel
}

// Status returns HTTPResponse.Status
func (r ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhookSubscriptionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookSubscriptionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetWithResponse request returning *MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse
func (c *ClientWithResponses) MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetWithResponse(ctx context.Context, params *MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams, reqEditors ...RequestEditorFn) (*MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse, error) {
	rsp, err := c.MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse(rsp)
}

// SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetWithResponse request returning *SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse
func (c *ClientWithResponses) SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse, error) {
	rsp, err := c.SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse(rsp)
}

// MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetWithResponse request returning *MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse
func (c *ClientWithResponses) MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetWithResponse(ctx context.Context, params *MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams, reqEditors ...RequestEditorFn) (*MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse, error) {
	rsp, err := c.MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse(rsp)
}

// SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetWithResponse request returning *SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse
func (c *ClientWithResponses) SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse, error) {
	rsp, err := c.SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse(rsp)
}

// MultipleDailySleepDocumentsV2UsercollectionDailySleepGetWithResponse request returning *MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse
func (c *ClientWithResponses) MultipleDailySleepDocumentsV2UsercollectionDailySleepGetWithResponse(ctx context.Context, params *MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams, reqEditors ...RequestEditorFn) (*MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse, error) {
	rsp, err := c.MultipleDailySleepDocumentsV2UsercollectionDailySleepGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse(rsp)
}

// SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetWithResponse request returning *SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse
func (c *ClientWithResponses) SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse, error) {
	rsp, err := c.SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse(rsp)
}

// MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetWithResponse request returning *MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse
func (c *ClientWithResponses) MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetWithResponse(ctx context.Context, params *MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams, reqEditors ...RequestEditorFn) (*MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse, error) {
	rsp, err := c.MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse(rsp)
}

// SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetWithResponse request returning *SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse
func (c *ClientWithResponses) SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse, error) {
	rsp, err := c.SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse(rsp)
}

// MultipleHeartRateDocumentsV2UsercollectionHeartrateGetWithResponse request returning *MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse
func (c *ClientWithResponses) MultipleHeartRateDocumentsV2UsercollectionHeartrateGetWithResponse(ctx context.Context, params *MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams, reqEditors ...RequestEditorFn) (*MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse, error) {
	rsp, err := c.MultipleHeartRateDocumentsV2UsercollectionHeartrateGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse(rsp)
}

// SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetWithResponse request returning *SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse
func (c *ClientWithResponses) SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse, error) {
	rsp, err := c.SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse(rsp)
}

// MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetWithResponse request returning *MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse
func (c *ClientWithResponses) MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetWithResponse(ctx context.Context, params *MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams, reqEditors ...RequestEditorFn) (*MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse, error) {
	rsp, err := c.MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse(rsp)
}

// SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetWithResponse request returning *SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse
func (c *ClientWithResponses) SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse, error) {
	rsp, err := c.SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse(rsp)
}

// MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetWithResponse request returning *MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse
func (c *ClientWithResponses) MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetWithResponse(ctx context.Context, params *MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams, reqEditors ...RequestEditorFn) (*MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse, error) {
	rsp, err := c.MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse(rsp)
}

// SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetWithResponse request returning *SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse
func (c *ClientWithResponses) SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse, error) {
	rsp, err := c.SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse(rsp)
}

// MultipleSessionDocumentsV2UsercollectionSessionGetWithResponse request returning *MultipleSessionDocumentsV2UsercollectionSessionGetResponse
func (c *ClientWithResponses) MultipleSessionDocumentsV2UsercollectionSessionGetWithResponse(ctx context.Context, params *MultipleSessionDocumentsV2UsercollectionSessionGetParams, reqEditors ...RequestEditorFn) (*MultipleSessionDocumentsV2UsercollectionSessionGetResponse, error) {
	rsp, err := c.MultipleSessionDocumentsV2UsercollectionSessionGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleSessionDocumentsV2UsercollectionSessionGetResponse(rsp)
}

// SingleSessionDocumentV2UsercollectionSessionDocumentIdGetWithResponse request returning *SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse
func (c *ClientWithResponses) SingleSessionDocumentV2UsercollectionSessionDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse, error) {
	rsp, err := c.SingleSessionDocumentV2UsercollectionSessionDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse(rsp)
}

// MultipleSleepDocumentsV2UsercollectionSleepGetWithResponse request returning *MultipleSleepDocumentsV2UsercollectionSleepGetResponse
func (c *ClientWithResponses) MultipleSleepDocumentsV2UsercollectionSleepGetWithResponse(ctx context.Context, params *MultipleSleepDocumentsV2UsercollectionSleepGetParams, reqEditors ...RequestEditorFn) (*MultipleSleepDocumentsV2UsercollectionSleepGetResponse, error) {
	rsp, err := c.MultipleSleepDocumentsV2UsercollectionSleepGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleSleepDocumentsV2UsercollectionSleepGetResponse(rsp)
}

// SingleSleepDocumentV2UsercollectionSleepDocumentIdGetWithResponse request returning *SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse
func (c *ClientWithResponses) SingleSleepDocumentV2UsercollectionSleepDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse, error) {
	rsp, err := c.SingleSleepDocumentV2UsercollectionSleepDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse(rsp)
}

// MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetWithResponse request returning *MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse
func (c *ClientWithResponses) MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetWithResponse(ctx context.Context, params *MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams, reqEditors ...RequestEditorFn) (*MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse, error) {
	rsp, err := c.MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse(rsp)
}

// SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetWithResponse request returning *SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse
func (c *ClientWithResponses) SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse, error) {
	rsp, err := c.SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse(rsp)
}

// MultipleTagDocumentsV2UsercollectionTagGetWithResponse request returning *MultipleTagDocumentsV2UsercollectionTagGetResponse
func (c *ClientWithResponses) MultipleTagDocumentsV2UsercollectionTagGetWithResponse(ctx context.Context, params *MultipleTagDocumentsV2UsercollectionTagGetParams, reqEditors ...RequestEditorFn) (*MultipleTagDocumentsV2UsercollectionTagGetResponse, error) {
	rsp, err := c.MultipleTagDocumentsV2UsercollectionTagGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleTagDocumentsV2UsercollectionTagGetResponse(rsp)
}

// SingleTagDocumentV2UsercollectionTagDocumentIdGetWithResponse request returning *SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse
func (c *ClientWithResponses) SingleTagDocumentV2UsercollectionTagDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse, error) {
	rsp, err := c.SingleTagDocumentV2UsercollectionTagDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleTagDocumentV2UsercollectionTagDocumentIdGetResponse(rsp)
}

// MultipleWorkoutDocumentsV2UsercollectionWorkoutGetWithResponse request returning *MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse
func (c *ClientWithResponses) MultipleWorkoutDocumentsV2UsercollectionWorkoutGetWithResponse(ctx context.Context, params *MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams, reqEditors ...RequestEditorFn) (*MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse, error) {
	rsp, err := c.MultipleWorkoutDocumentsV2UsercollectionWorkoutGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse(rsp)
}

// SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetWithResponse request returning *SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse
func (c *ClientWithResponses) SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetWithResponse(ctx context.Context, documentId string, reqEditors ...RequestEditorFn) (*SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse, error) {
	rsp, err := c.SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet(ctx, documentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse(rsp)
}

// ListWebhookSubscriptionsV2WebhookSubscriptionGetWithResponse request returning *ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse
func (c *ClientWithResponses) ListWebhookSubscriptionsV2WebhookSubscriptionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse, error) {
	rsp, err := c.ListWebhookSubscriptionsV2WebhookSubscriptionGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhookSubscriptionsV2WebhookSubscriptionGetResponse(rsp)
}

// CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBodyWithResponse request with arbitrary body returning *CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse
func (c *ClientWithResponses) CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse, error) {
	rsp, err := c.CreateWebhookSubscriptionV2WebhookSubscriptionPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSubscriptionV2WebhookSubscriptionPostResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookSubscriptionV2WebhookSubscriptionPostWithResponse(ctx context.Context, body CreateWebhookSubscriptionV2WebhookSubscriptionPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse, error) {
	rsp, err := c.CreateWebhookSubscriptionV2WebhookSubscriptionPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookSubscriptionV2WebhookSubscriptionPostResponse(rsp)
}

// RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutWithResponse request returning *RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse
func (c *ClientWithResponses) RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse, error) {
	rsp, err := c.RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse(rsp)
}

// DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteWithResponse request returning *DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse
func (c *ClientWithResponses) DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse, error) {
	rsp, err := c.DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse(rsp)
}

// GetWebhookSubscriptionV2WebhookSubscriptionIdGetWithResponse request returning *GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse
func (c *ClientWithResponses) GetWebhookSubscriptionV2WebhookSubscriptionIdGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse, error) {
	rsp, err := c.GetWebhookSubscriptionV2WebhookSubscriptionIdGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse(rsp)
}

// UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBodyWithResponse request with arbitrary body returning *UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse
func (c *ClientWithResponses) UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse, error) {
	rsp, err := c.UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithResponse(ctx context.Context, id string, body UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse, error) {
	rsp, err := c.UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse(rsp)
}

// ParseMultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse parses an HTTP response from a MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetWithResponse call
func ParseMultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse(rsp *http.Response) (*MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseDailyActivityModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse parses an HTTP response from a SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetWithResponse call
func ParseSingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse(rsp *http.Response) (*SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyActivityModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse parses an HTTP response from a MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetWithResponse call
func ParseMultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse(rsp *http.Response) (*MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseDailyReadinessModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse parses an HTTP response from a SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetWithResponse call
func ParseSingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse(rsp *http.Response) (*SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyReadinessModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse parses an HTTP response from a MultipleDailySleepDocumentsV2UsercollectionDailySleepGetWithResponse call
func ParseMultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse(rsp *http.Response) (*MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleDailySleepDocumentsV2UsercollectionDailySleepGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseDailySleepModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse parses an HTTP response from a SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetWithResponse call
func ParseSingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse(rsp *http.Response) (*SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailySleepModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse parses an HTTP response from a MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetWithResponse call
func ParseMultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse(rsp *http.Response) (*MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseDailySpO2Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse parses an HTTP response from a SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetWithResponse call
func ParseSingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse(rsp *http.Response) (*SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailySpO2Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse parses an HTTP response from a MultipleHeartRateDocumentsV2UsercollectionHeartrateGetWithResponse call
func ParseMultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse(rsp *http.Response) (*MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleHeartRateDocumentsV2UsercollectionHeartrateGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HeartRateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse parses an HTTP response from a SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetWithResponse call
func ParseSinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse(rsp *http.Response) (*SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonalInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse parses an HTTP response from a MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetWithResponse call
func ParseMultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse(rsp *http.Response) (*MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseRestModePeriodModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse parses an HTTP response from a SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetWithResponse call
func ParseSingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse(rsp *http.Response) (*SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestModePeriodModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse parses an HTTP response from a MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetWithResponse call
func ParseMultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse(rsp *http.Response) (*MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseRingConfigurationModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse parses an HTTP response from a SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetWithResponse call
func ParseSingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse(rsp *http.Response) (*SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RingConfigurationModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleSessionDocumentsV2UsercollectionSessionGetResponse parses an HTTP response from a MultipleSessionDocumentsV2UsercollectionSessionGetWithResponse call
func ParseMultipleSessionDocumentsV2UsercollectionSessionGetResponse(rsp *http.Response) (*MultipleSessionDocumentsV2UsercollectionSessionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleSessionDocumentsV2UsercollectionSessionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseSessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse parses an HTTP response from a SingleSessionDocumentV2UsercollectionSessionDocumentIdGetWithResponse call
func ParseSingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse(rsp *http.Response) (*SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleSessionDocumentV2UsercollectionSessionDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleSleepDocumentsV2UsercollectionSleepGetResponse parses an HTTP response from a MultipleSleepDocumentsV2UsercollectionSleepGetWithResponse call
func ParseMultipleSleepDocumentsV2UsercollectionSleepGetResponse(rsp *http.Response) (*MultipleSleepDocumentsV2UsercollectionSleepGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleSleepDocumentsV2UsercollectionSleepGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseSleepModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse parses an HTTP response from a SingleSleepDocumentV2UsercollectionSleepDocumentIdGetWithResponse call
func ParseSingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse(rsp *http.Response) (*SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleSleepDocumentV2UsercollectionSleepDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SleepModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse parses an HTTP response from a MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetWithResponse call
func ParseMultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse(rsp *http.Response) (*MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseSleepTimeModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse parses an HTTP response from a SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetWithResponse call
func ParseSingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse(rsp *http.Response) (*SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SleepTimeModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleTagDocumentsV2UsercollectionTagGetResponse parses an HTTP response from a MultipleTagDocumentsV2UsercollectionTagGetWithResponse call
func ParseMultipleTagDocumentsV2UsercollectionTagGetResponse(rsp *http.Response) (*MultipleTagDocumentsV2UsercollectionTagGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleTagDocumentsV2UsercollectionTagGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseTagModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleTagDocumentV2UsercollectionTagDocumentIdGetResponse parses an HTTP response from a SingleTagDocumentV2UsercollectionTagDocumentIdGetWithResponse call
func ParseSingleTagDocumentV2UsercollectionTagDocumentIdGetResponse(rsp *http.Response) (*SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleTagDocumentV2UsercollectionTagDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse parses an HTTP response from a MultipleWorkoutDocumentsV2UsercollectionWorkoutGetWithResponse call
func ParseMultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse(rsp *http.Response) (*MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MultipleWorkoutDocumentsV2UsercollectionWorkoutGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MultiDocumentResponseWorkoutModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse parses an HTTP response from a SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetWithResponse call
func ParseSingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse(rsp *http.Response) (*SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkoutModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListWebhookSubscriptionsV2WebhookSubscriptionGetResponse parses an HTTP response from a ListWebhookSubscriptionsV2WebhookSubscriptionGetWithResponse call
func ParseListWebhookSubscriptionsV2WebhookSubscriptionGetResponse(rsp *http.Response) (*ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhookSubscriptionsV2WebhookSubscriptionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WebhookSubscriptionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWebhookSubscriptionV2WebhookSubscriptionPostResponse parses an HTTP response from a CreateWebhookSubscriptionV2WebhookSubscriptionPostWithResponse call
func ParseCreateWebhookSubscriptionV2WebhookSubscriptionPostResponse(rsp *http.Response) (*CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookSubscriptionV2WebhookSubscriptionPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhookSubscriptionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse parses an HTTP response from a RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutWithResponse call
func ParseRenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse(rsp *http.Response) (*RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse parses an HTTP response from a DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteWithResponse call
func ParseDeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse(rsp *http.Response) (*DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookSubscriptionV2WebhookSubscriptionIdDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse parses an HTTP response from a GetWebhookSubscriptionV2WebhookSubscriptionIdGetWithResponse call
func ParseGetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse(rsp *http.Response) (*GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookSubscriptionV2WebhookSubscriptionIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse parses an HTTP response from a UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutWithResponse call
func ParseUpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse(rsp *http.Response) (*UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookSubscriptionV2WebhookSubscriptionIdPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookSubscriptionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Multiple Daily Activity Documents
	// (GET /v2/usercollection/daily_activity)
	MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet(ctx echo.Context, params MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams) error
	// Single Daily Activity Document
	// (GET /v2/usercollection/daily_activity/{document_id})
	SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Daily Readiness Documents
	// (GET /v2/usercollection/daily_readiness)
	MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet(ctx echo.Context, params MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams) error
	// Single Daily Readiness Document
	// (GET /v2/usercollection/daily_readiness/{document_id})
	SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Daily Sleep Documents
	// (GET /v2/usercollection/daily_sleep)
	MultipleDailySleepDocumentsV2UsercollectionDailySleepGet(ctx echo.Context, params MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams) error
	// Single Daily Sleep Document
	// (GET /v2/usercollection/daily_sleep/{document_id})
	SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Daily Spo2 Documents
	// (GET /v2/usercollection/daily_spo2)
	MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get(ctx echo.Context, params MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams) error
	// Single Daily Spo2 Document
	// (GET /v2/usercollection/daily_spo2/{document_id})
	SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Heart Rate Documents
	// (GET /v2/usercollection/heartrate)
	MultipleHeartRateDocumentsV2UsercollectionHeartrateGet(ctx echo.Context, params MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams) error
	// Single Personal Info Document
	// (GET /v2/usercollection/personal_info)
	SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet(ctx echo.Context) error
	// Multiple Rest Mode Period Documents
	// (GET /v2/usercollection/rest_mode_period)
	MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet(ctx echo.Context, params MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams) error
	// Single Rest Mode Period Document
	// (GET /v2/usercollection/rest_mode_period/{document_id})
	SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Ring Configuration Documents
	// (GET /v2/usercollection/ring_configuration)
	MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet(ctx echo.Context, params MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams) error
	// Single Ring Configuration Document
	// (GET /v2/usercollection/ring_configuration/{document_id})
	SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Session Documents
	// (GET /v2/usercollection/session)
	MultipleSessionDocumentsV2UsercollectionSessionGet(ctx echo.Context, params MultipleSessionDocumentsV2UsercollectionSessionGetParams) error
	// Single Session Document
	// (GET /v2/usercollection/session/{document_id})
	SingleSessionDocumentV2UsercollectionSessionDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Sleep Documents
	// (GET /v2/usercollection/sleep)
	MultipleSleepDocumentsV2UsercollectionSleepGet(ctx echo.Context, params MultipleSleepDocumentsV2UsercollectionSleepGetParams) error
	// Single Sleep Document
	// (GET /v2/usercollection/sleep/{document_id})
	SingleSleepDocumentV2UsercollectionSleepDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Sleep Time Documents
	// (GET /v2/usercollection/sleep_time)
	MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet(ctx echo.Context, params MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams) error
	// Single Sleep Time Document
	// (GET /v2/usercollection/sleep_time/{document_id})
	SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Tag Documents
	// (GET /v2/usercollection/tag)
	MultipleTagDocumentsV2UsercollectionTagGet(ctx echo.Context, params MultipleTagDocumentsV2UsercollectionTagGetParams) error
	// Single Tag Document
	// (GET /v2/usercollection/tag/{document_id})
	SingleTagDocumentV2UsercollectionTagDocumentIdGet(ctx echo.Context, documentId string) error
	// Multiple Workout Documents
	// (GET /v2/usercollection/workout)
	MultipleWorkoutDocumentsV2UsercollectionWorkoutGet(ctx echo.Context, params MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams) error
	// Single Workout Document
	// (GET /v2/usercollection/workout/{document_id})
	SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet(ctx echo.Context, documentId string) error
	// List Webhook Subscriptions
	// (GET /v2/webhook/subscription)
	ListWebhookSubscriptionsV2WebhookSubscriptionGet(ctx echo.Context) error
	// Create Webhook Subscription
	// (POST /v2/webhook/subscription)
	CreateWebhookSubscriptionV2WebhookSubscriptionPost(ctx echo.Context) error
	// Renew Webhook Subscription
	// (PUT /v2/webhook/subscription/renew/{id})
	RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut(ctx echo.Context, id string) error
	// Delete Webhook Subscription
	// (DELETE /v2/webhook/subscription/{id})
	DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete(ctx echo.Context, id string) error
	// Get Webhook Subscription
	// (GET /v2/webhook/subscription/{id})
	GetWebhookSubscriptionV2WebhookSubscriptionIdGet(ctx echo.Context, id string) error
	// Update Webhook Subscription
	// (PUT /v2/webhook/subscription/{id})
	UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet(ctx, params)
	return err
}

// SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet(ctx, documentId)
	return err
}

// MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet(ctx, params)
	return err
}

// SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet(ctx, documentId)
	return err
}

// MultipleDailySleepDocumentsV2UsercollectionDailySleepGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleDailySleepDocumentsV2UsercollectionDailySleepGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleDailySleepDocumentsV2UsercollectionDailySleepGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleDailySleepDocumentsV2UsercollectionDailySleepGet(ctx, params)
	return err
}

// SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet(ctx, documentId)
	return err
}

// MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleDailySpo2DocumentsV2UsercollectionDailySpo2GetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get(ctx, params)
	return err
}

// SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet(ctx, documentId)
	return err
}

// MultipleHeartRateDocumentsV2UsercollectionHeartrateGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleHeartRateDocumentsV2UsercollectionHeartrateGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleHeartRateDocumentsV2UsercollectionHeartrateGetParams
	// ------------- Optional query parameter "start_datetime" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_datetime", ctx.QueryParams(), &params.StartDatetime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_datetime: %s", err))
	}

	// ------------- Optional query parameter "end_datetime" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_datetime", ctx.QueryParams(), &params.EndDatetime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_datetime: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleHeartRateDocumentsV2UsercollectionHeartrateGet(ctx, params)
	return err
}

// SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet(ctx)
	return err
}

// MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet(ctx, params)
	return err
}

// SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet(ctx, documentId)
	return err
}

// MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet(ctx, params)
	return err
}

// SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet(ctx, documentId)
	return err
}

// MultipleSessionDocumentsV2UsercollectionSessionGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleSessionDocumentsV2UsercollectionSessionGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleSessionDocumentsV2UsercollectionSessionGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleSessionDocumentsV2UsercollectionSessionGet(ctx, params)
	return err
}

// SingleSessionDocumentV2UsercollectionSessionDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleSessionDocumentV2UsercollectionSessionDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleSessionDocumentV2UsercollectionSessionDocumentIdGet(ctx, documentId)
	return err
}

// MultipleSleepDocumentsV2UsercollectionSleepGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleSleepDocumentsV2UsercollectionSleepGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleSleepDocumentsV2UsercollectionSleepGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleSleepDocumentsV2UsercollectionSleepGet(ctx, params)
	return err
}

// SingleSleepDocumentV2UsercollectionSleepDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleSleepDocumentV2UsercollectionSleepDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleSleepDocumentV2UsercollectionSleepDocumentIdGet(ctx, documentId)
	return err
}

// MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet(ctx, params)
	return err
}

// SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet(ctx, documentId)
	return err
}

// MultipleTagDocumentsV2UsercollectionTagGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleTagDocumentsV2UsercollectionTagGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleTagDocumentsV2UsercollectionTagGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleTagDocumentsV2UsercollectionTagGet(ctx, params)
	return err
}

// SingleTagDocumentV2UsercollectionTagDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleTagDocumentV2UsercollectionTagDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleTagDocumentV2UsercollectionTagDocumentIdGet(ctx, documentId)
	return err
}

// MultipleWorkoutDocumentsV2UsercollectionWorkoutGet converts echo context to params.
func (w *ServerInterfaceWrapper) MultipleWorkoutDocumentsV2UsercollectionWorkoutGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params MultipleWorkoutDocumentsV2UsercollectionWorkoutGetParams
	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_date: %s", err))
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_date: %s", err))
	}

	// ------------- Optional query parameter "next_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_token", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MultipleWorkoutDocumentsV2UsercollectionWorkoutGet(ctx, params)
	return err
}

// SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "document_id" -------------
	var documentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "document_id", runtime.ParamLocationPath, ctx.Param("document_id"), &documentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter document_id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet(ctx, documentId)
	return err
}

// ListWebhookSubscriptionsV2WebhookSubscriptionGet converts echo context to params.
func (w *ServerInterfaceWrapper) ListWebhookSubscriptionsV2WebhookSubscriptionGet(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWebhookSubscriptionsV2WebhookSubscriptionGet(ctx)
	return err
}

// CreateWebhookSubscriptionV2WebhookSubscriptionPost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWebhookSubscriptionV2WebhookSubscriptionPost(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateWebhookSubscriptionV2WebhookSubscriptionPost(ctx)
	return err
}

// RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut converts echo context to params.
func (w *ServerInterfaceWrapper) RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut(ctx, id)
	return err
}

// DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete(ctx, id)
	return err
}

// GetWebhookSubscriptionV2WebhookSubscriptionIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetWebhookSubscriptionV2WebhookSubscriptionIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWebhookSubscriptionV2WebhookSubscriptionIdGet(ctx, id)
	return err
}

// UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/usercollection/daily_activity", wrapper.MultipleDailyActivityDocumentsV2UsercollectionDailyActivityGet)
	router.GET(baseURL+"/v2/usercollection/daily_activity/:document_id", wrapper.SingleDailyActivityDocumentV2UsercollectionDailyActivityDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/daily_readiness", wrapper.MultipleDailyReadinessDocumentsV2UsercollectionDailyReadinessGet)
	router.GET(baseURL+"/v2/usercollection/daily_readiness/:document_id", wrapper.SingleDailyReadinessDocumentV2UsercollectionDailyReadinessDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/daily_sleep", wrapper.MultipleDailySleepDocumentsV2UsercollectionDailySleepGet)
	router.GET(baseURL+"/v2/usercollection/daily_sleep/:document_id", wrapper.SingleDailySleepDocumentV2UsercollectionDailySleepDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/daily_spo2", wrapper.MultipleDailySpo2DocumentsV2UsercollectionDailySpo2Get)
	router.GET(baseURL+"/v2/usercollection/daily_spo2/:document_id", wrapper.SingleDailySpo2DocumentV2UsercollectionDailySpo2DocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/heartrate", wrapper.MultipleHeartRateDocumentsV2UsercollectionHeartrateGet)
	router.GET(baseURL+"/v2/usercollection/personal_info", wrapper.SinglePersonalInfoDocumentV2UsercollectionPersonalInfoGet)
	router.GET(baseURL+"/v2/usercollection/rest_mode_period", wrapper.MultipleRestModePeriodDocumentsV2UsercollectionRestModePeriodGet)
	router.GET(baseURL+"/v2/usercollection/rest_mode_period/:document_id", wrapper.SingleRestModePeriodDocumentV2UsercollectionRestModePeriodDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/ring_configuration", wrapper.MultipleRingConfigurationDocumentsV2UsercollectionRingConfigurationGet)
	router.GET(baseURL+"/v2/usercollection/ring_configuration/:document_id", wrapper.SingleRingConfigurationDocumentV2UsercollectionRingConfigurationDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/session", wrapper.MultipleSessionDocumentsV2UsercollectionSessionGet)
	router.GET(baseURL+"/v2/usercollection/session/:document_id", wrapper.SingleSessionDocumentV2UsercollectionSessionDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/sleep", wrapper.MultipleSleepDocumentsV2UsercollectionSleepGet)
	router.GET(baseURL+"/v2/usercollection/sleep/:document_id", wrapper.SingleSleepDocumentV2UsercollectionSleepDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/sleep_time", wrapper.MultipleSleepTimeDocumentsV2UsercollectionSleepTimeGet)
	router.GET(baseURL+"/v2/usercollection/sleep_time/:document_id", wrapper.SingleSleepTimeDocumentV2UsercollectionSleepTimeDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/tag", wrapper.MultipleTagDocumentsV2UsercollectionTagGet)
	router.GET(baseURL+"/v2/usercollection/tag/:document_id", wrapper.SingleTagDocumentV2UsercollectionTagDocumentIdGet)
	router.GET(baseURL+"/v2/usercollection/workout", wrapper.MultipleWorkoutDocumentsV2UsercollectionWorkoutGet)
	router.GET(baseURL+"/v2/usercollection/workout/:document_id", wrapper.SingleWorkoutDocumentV2UsercollectionWorkoutDocumentIdGet)
	router.GET(baseURL+"/v2/webhook/subscription", wrapper.ListWebhookSubscriptionsV2WebhookSubscriptionGet)
	router.POST(baseURL+"/v2/webhook/subscription", wrapper.CreateWebhookSubscriptionV2WebhookSubscriptionPost)
	router.PUT(baseURL+"/v2/webhook/subscription/renew/:id", wrapper.RenewWebhookSubscriptionV2WebhookSubscriptionRenewIdPut)
	router.DELETE(baseURL+"/v2/webhook/subscription/:id", wrapper.DeleteWebhookSubscriptionV2WebhookSubscriptionIdDelete)
	router.GET(baseURL+"/v2/webhook/subscription/:id", wrapper.GetWebhookSubscriptionV2WebhookSubscriptionIdGet)
	router.PUT(baseURL+"/v2/webhook/subscription/:id", wrapper.UpdateWebhookSubscriptionV2WebhookSubscriptionIdPut)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
